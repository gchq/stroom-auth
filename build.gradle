/*
 * Copyright 2017 Crown Copyright
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
    }
    dependencies {
        classpath('io.swagger:swagger-codegen:2.2.2') // Generates client from YAML/JSON
        classpath 'mysql:mysql-connector-java:8.0.19'
    }
}

plugins {
    id 'com.github.johnrengelman.shadow' version '6.1.0' apply false
    id 'com.benjaminsproule.swagger' version "0.1.4" apply false // Generates YAML/JSON from model
    id 'nu.studer.jooq' version '3.0.2' apply false
    id 'org.flywaydb.flyway' version '5.1.4'
    id "signing"
    id "io.github.gradle-nexus.publish-plugin" version "1.0.0"
}

if(JavaVersion.current() != JavaVersion.VERSION_1_8){
    throw new GradleException("This build must be run with java 8")
}

ext.isPropertySet = { propName ->
    if (!project.hasProperty(propName)) {
        return false
    } else {
        def prop = project.getProperty(propName)
        return (prop != "unspecified" && prop != "" && prop != null)
    }
}

ext.ensurePropertyIsSet = { propName -> 
    if (!isPropertySet(propName)) {
        throw new GradleException(
            "Expecting project property [${propName}] or env var [ORG_GRADLE_PROJECT_${propName}] to be set.")
    }
}

//if the project has a value for the passed property (i.e from the cmd line via -PpropName=xxx)
//use that, else use a default value
ext.getPropertyOrDefault = { propName, defaultValue ->
    def val;
    if (isPropertySet(propName)) {
        val = project.getProperty(propName)
        println "Getting property [$propName] with value [$val]"
    } else {
        val = defaultValue
        println "Property [$propName] has no value, using default value [$val]"
    }
    return val;
}

ext.versions = [
    stroomAuth: getPropertyOrDefault('version', 'SNAPSHOT').replaceFirst(/^v/, ""),

    dropwizard: '1.2.0',
    jooq: '3.11.7',
    dropwizard_jooq:'1.1.0-0',
    shiro: '1.3.2',
    curator: '2.12.0',
    swagger: '1.5.16',
    eventLogging: '3.3.1_schema-v3.3.1',
    jaxb: '2.2.11',
]

ext.testVersions = [
    junit: '4.12',
    junit_jupiter: '5.2.0'
]

ext.deps = [

    // Stroom family deps
    eventLogging: "uk.gov.gchq.eventlogging:event-logging:$versions.eventLogging",

    bcrypt: 'de.svenkubiak:jBCrypt:0.4.1',
    curator_client: "org.apache.curator:curator-client:$versions.curator",
    curator_framework: "org.apache.curator:curator-framework:$versions.curator",
    curator_recipies: "org.apache.curator:curator-recipes:$versions.curator",
    curator_service_discovery: "org.apache.curator:curator-x-discovery:$versions.curator",
    dropwizard_auth: "io.dropwizard:dropwizard-auth:$versions.dropwizard",
    dropwizard_auth_jwt: "com.github.toastshaman:dropwizard-auth-jwt:1.0.2-0",
    dropwizard_core: "io.dropwizard:dropwizard-core:$versions.dropwizard",
    dropwizard_flyway: 'io.dropwizard.modules:dropwizard-flyway:1.2.0-1',
    dropwizard_jersey: "io.dropwizard:dropwizard-jersey:$versions.dropwizard",
    dropwizard_jooq: "com.bendb.dropwizard:dropwizard-jooq:$versions.dropwizard_jooq",
    flyway_core: "org.flywaydb:flyway-core:4.2.0",
    guice: "com.google.inject:guice:4.0",
    javax_annotations: "javax.annotation:javax.annotation-api:1.3.2",
    jaxws_api: "javax.xml.ws:jaxws-api:2.2.6",
    jooq: "org.jooq:jooq:$versions.jooq",
    jooq_codegen: "org.jooq:jooq-codegen:$versions.jooq",
    jooq_meta: "org.jooq:jooq-meta:$versions.jooq",
    jose4j: "org.bitbucket.b_c:jose4j:0.6.4",
    mysql_connector_java: "mysql:mysql-connector-java:8.0.19",
    shiro_core: "org.apache.shiro:shiro-core:$versions.shiro",
    simple_java_mail: 'org.simplejavamail:simple-java-mail:4.3.0',
    slf4j: "org.slf4j:slf4j-api:1.7.21",
    swagger_annotations: "io.swagger:swagger-annotations:$versions.swagger",
    okhttp: 'com.squareup.okhttp:okhttp:2.7.5',
    okhttp_logginer_interceptor: 'com.squareup.okhttp:logging-interceptor:2.7.5',
    gson: 'com.google.code.gson:gson:2.6.2',
    joda_time: 'joda-time:joda-time:2.9.3',
    jaxb_api: "javax.xml.bind:jaxb-api:$versions.jaxb",
    jaxb_core: "com.sun.xml.bind:jaxb-core:$versions.jaxb",
    jaxb_impl: "com.sun.xml.bind:jaxb-impl:$versions.jaxb",
    javax_activation: 'javax.activation:activation:1.1.1',
]

ext.testDeps = [
    assertj: 'org.assertj:assertj-core:3.8.0',
    dropwizard_testing: "io.dropwizard:dropwizard-testing:$versions.dropwizard",
    fuel: 'com.github.kittinunf.fuel:fuel:1.7.0',
    junit: "junit:junit:$testVersions.junit",
    junit_jupiter: "org.junit.jupiter:junit-jupiter-api:$testVersions.junit_jupiter",
    moshi: 'com.squareup.moshi:moshi:1.5.0',
    unirest: 'com.mashape.unirest:unirest-java:1.4.9',
    wiremock: 'com.github.tomakehurst:wiremock:2.12.0',
    test_containers_mysql: 'org.testcontainers:mysql:1.9.1',
    mockito: 'org.mockito:mockito-core:2.23.0',
]

ext.isReleaseBuild = !versions.stroomAuth.endsWith('SNAPSHOT')
def mavenGroupId = 'uk.gov.gchq.stroom.auth'

// Configure maven coordinates
group = mavenGroupId
version = versions.stroomAuth

if (isReleaseBuild) {
    println "This is a release build for maven version [${versions.stroomAuth}]"
    // Ensure the various props are set for signing and publishing to sonatype

    // The username for Sonatype OSSRH Jira account
    ensurePropertyIsSet("sonatypeUsername")
    // The password for Sonatype OSSRH Jira account
    ensurePropertyIsSet("sonatypePassword")
    // The GPG2 secret key in ascii armour format, base64 encoded
    ensurePropertyIsSet("signingKey")
    // The password for the GPG2 secret key
    ensurePropertyIsSet("signingPassword")
}

// Defines a list of gradle projects that we will publish with maven/sonatype
// Be sure to define 'project.ext.pomDescription' in each one
def projectsToBePublished = subprojects.findAll { project -> 
    project.path in [
        ':stroom-auth-service-api',
    ] 
}

def javaProjects = subprojects.findAll { project -> 
    project.path in [
        ':stroom-persistence',
        ':stroom-auth-service-api',
        ':stroom-auth-svc',
    ] 
}


String base64DecodeProjectProperty(String propName) {
    def encodedVal = project.findProperty(propName)
    return encodedVal == null
        ? null
        : new String(Base64.getDecoder().decode(encodedVal.toString())).trim()
}

void configureSigning(Project project) {

    // To create the GPG key do:
    //   gpg2 --gen-key 
    // To list it
    //   gpg2 --list-keys
    // To publish the public key on a keyserver
    //   gpg2 --keyserver hkp://keyserver.ubuntu.com --send-keys <your short key id>
    // To get the ascii-armour private key for use in travis env vars as base64 encoded
    //   gpg2 --armor --export-secret-keys <your short key id> | base64 -w0

    //project.signing.gnupg.keyName = project.findProperty("signingKeyId")

    project.signing {
        println "Configuring project to sign maven artifacts"
        required { project.gradle.taskGraph.hasTask("required") }
        def signingKeyId = project.findProperty("signingKeyId")
        def signingKey = base64DecodeProjectProperty("signingKey")
        def signingPassword = project.findProperty("signingPassword")

        //println "pword: [$signingPassword]"
        //println "key: [$signingKey]"
        //println "keyId: [$signingKeyId]"

        if (signingKeyId) {
            println "Using in memory pgp key with ID"
            useInMemoryPgpKeys(signingKeyId, signingKey, signingPassword)
        } else if (signingKey) {
            println "Using in memory pgp key without ID"
            useInMemoryPgpKeys(signingKey, signingPassword)
        }
        //useGpgCmd()
        sign project.publishing.publications.mavenJava
    }
}

apply plugin: 'io.github.gradle-nexus.publish-plugin'

//Configuration applicable to all projects
allprojects {
}

//Configuration applicable to all sub projects
subprojects {
}

//configures only those projects in javaProjects
configure(javaProjects) {

    println "Configuring ${project.path} for java"

    apply plugin: 'java'
    apply plugin: 'idea'

    // Stroom v6 is j8 and it uses the auth api lib so need to target j8
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8

    repositories {
        mavenLocal()
        mavenCentral()
    }

    sourceSets {
        // This lets us use different directories for our integration tests.
        integrationTest {
            java {
                compileClasspath += main.output + test.output
                runtimeClasspath += main.output + test.output
                srcDir file('src/integration-test/java')
            }
            resources.srcDir file('src/integration-test/resources')
        }
    }

    configurations {

        //ensure deps don't bring any logging implementations with them as this will
        //conflict with logback. Also replace any log4j deps with log4j-over-slf4j
        //so dependency jars work with slf4j
        all {
            exclude group: "org.slf4j", module: "slf4j-log4j12"
            exclude group: "log4j", module: "log4j"

            resolutionStrategy.eachDependency { DependencyResolveDetails details ->
                if (details.requested.name == 'log4j') {
                    details.useTarget "org.slf4j:log4j-over-slf4j:$versions.slf4j"
                }
            }
            resolutionStrategy {
                forcedModules = [
                ]
            }
        }
        
        // This means our integration tests get all the dependencies from our tests and we don't need to specify them twice.
        integrationTestCompile.extendsFrom testCompile
        integrationTestRuntime.extendsFrom testRuntime
    }

    // This means the reports from our integration tests won't over-write the reports from our unit tests.
    tasks.withType(Test) {
        reports.html.destination = file("${reporting.baseDir}/${name}")

        //Use full logging for test exceptions so we can see where the failure occurred 
        testLogging {
            events "failed"
            exceptionFormat = 'full'
            showStackTraces = true
        }
    }

    // This task lets us run the actual integration tests.
    task integrationTest(type: Test) {
        testClassesDirs = sourceSets.integrationTest.output.classesDirs
        classpath = sourceSets.integrationTest.runtimeClasspath

        // Integration tests are quite slow so output progress for each test to keep travis alive
        afterTest { desc, result -> 
            println "Executed test ${desc.name} [${desc.className}] with result: ${result.resultType}"
        }

        //Use full logging for test exceptions so we can see where the failure occurred 
        testLogging {
            events "failed"
            exceptionFormat = 'full'
            showStackTraces = true
        }
    }

    clean{
        //clear out the 'out' dirs used by intelliJ
        delete "out"
    }

    // These lines pull the integration test task into our build process.
    tasks.check.dependsOn integrationTest
    tasks.integrationTest.mustRunAfter test
}

//configures only those projects in publishedProjectsPaths
configure(projectsToBePublished) { publishedProject ->

    println "Configuring ${project.path} for publishing"

    apply plugin: 'maven-publish'
    apply plugin: 'signing'

    group = mavenGroupId
    version = versions.stroomAuth

    //for java plugin
    //see https://docs.gradle.org/current/userguide/java_plugin.html
    java {
        //package JavaDoc as part of publication
        withJavadocJar()
        //package Sources as part of publication
        withSourcesJar()
    }

    // afterEvaluate so we can ensure the project's ext.pomDescription prop has been set
    project.afterEvaluate {
        publishing {
            publications {
                mavenJava(MavenPublication) {
                    from components.java

                    pom {
                        name = project['name']
                        description = publishedProject.ext.pomDescription 
                        url = 'https://github.com/gchq/stroom-auth'
                        licenses {
                            license {
                                name = 'The Apache License, Version 2.0'
                                url = 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                            }
                        }
                        developers {
                            developer {
                                name = 'GCHQDevelopers'
                                organization = 'GCQH'
                                organizationUrl = 'https://github.com/gchq'
                            }
                        }
                        scm {
                            connection = 'scm:git:git@github.com:gchq/stroom-auth.git'
                            developerConnection = 'scm:git:git@github.com:gchq/stroom-auth.git'
                            url = 'https://github.com/gchq/stroom-auth'
                        }
                    }         
                }
            }
        }

        def hasSigningKey = project.hasProperty("signingkeyId") || project.findProperty("signingKey")
        if(hasSigningKey) {
            configureSigning(project)
        }
    }
}

// Uses sonotypeUsername and sonotypePassword
// See https://github.com/rwinch/gradle-publish-ossrh-sample
// Also https://github.com/kit-data-manager/nexus-publish-example
nexusPublishing {
    repositories {
        sonatype()    //sonatypeUsername and sonatypePassword properties are used automatically
    }
    // these are not strictly required. The default timeouts are set to 1 minute. But Sonatype can be really slow.
    // If you get the error "java.net.SocketTimeoutException: timeout", these lines will help.
    connectTimeout = Duration.ofMinutes(3)
    clientTimeout = Duration.ofMinutes(3)
}
